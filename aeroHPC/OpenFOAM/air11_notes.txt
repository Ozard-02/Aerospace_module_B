TEST CASE
test/chemistry/air11

The folder name is air11, but we are only considering 5 species. Initially, there was concern that changing the folder name could break the case, but this is not an issue.

--------------------------------------------------------------------
SOLVER
ShockThermo

ShockThermo is derived from ShockFluid.

--------------------------------------------------------------------
GENERAL IDEA

At each time iteration, the solver executes several methods. The only method of interest for this work is thermophysicalPredictor.

The test case consists of a single cell where the initial velocity U = 0. Transport effects (momentum equation) are not relevant for this study. The goal is simply to call solver.thermophysicalPredictor() so that T and Tve (two-temperature model) are updated at each iteration.

--------------------------------------------------------------------
KEY PART OF thermophysicalPredictor

The most important part of thermophysicalPredictor is the call to:

    thermo_.correct()

(lines 129 to 138 in the source code)

In an ideal implementation, the solver should not be modified. The idea is that if we instantiate a custom thermodynamics model (e.g. highEnthalpyMulticomponentThermo), calling thermo_.correct() should automatically dispatch the correct overridden method.

However, this does not work as expected because highEnthalpyMulticomponentThermo is derived from PsiThermo, and the correct() method that gets called is the one from PsiThermo, not the overridden implementation we need.

--------------------------------------------------------------------
WORKAROUND IMPLEMENTED IN ShockThermo

To solve this, the solver ShockThermo was modified by adding a new pointer:

    highEnthalpyMulticomponentThermo* heThermoPtr_;

In the constructor of ShockThermo:
- If the selected thermodynamics model is highEnthalpyMulticomponentThermo, heThermoPtr_ is initialized.
- Otherwise, it is set to null.

Inside thermophysicalPredictor:

    if (heThermoPtr_ == null)
    {
        thermo_.correct();
    }
    else
    {
        heThermoPtr_->correct_he();
    }

This guarantees that the correct thermodynamics update method is used when highEnthalpyMulticomponentThermo is active.

--------------------------------------------------------------------
OPENFOAM STATE VARIABLES

At each iteration, OpenFOAM provides the following fields:

- U : velocity
  - U[i] is the velocity of cell i
- p : pressure
  - p[i] is the pressure of cell i
- Y : species mass fractions
  - Y[i] represents species i
  - Y[i][j] is the mass fraction of species i in cell j
- T : translational (transport) temperature
  - T[i] is the temperature of cell i

The number of species is defined in the 0/ directory of the test case.

--------------------------------------------------------------------
ADDITIONAL VARIABLES REQUIRED

To reproduce the reference paper, additional variables are required:

- Tve : vibrational temperature
- Et  : translational energy
- Ev  : vibrational energy

These variables are created and initialized in the constructor of highEnthalpyMulticomponentThermo.

--------------------------------------------------------------------
MUTATION++ INTERFACE

highEnthalpyMulticomponentThermo relies on Mutation++.

Mutation++ must know exactly which species are being used. This is handled in the constructor of highEnthalpyMulticomponentThermo (lines 119 to 124).

It is critical that the species order is consistent between OpenFOAM and Mutation++.

Example:
- If Y[0] in OpenFOAM corresponds to species O
- Then O must also be the first species in Mutation++

This consistency is ensured in lines 128 to 143 of the constructor.

The variables Et and Ev are also initialized in the constructor.

--------------------------------------------------------------------
SENDING THE STATE TO MUTATION++

Mutation++ requires the full thermodynamic state:

- U
- p
- Y
- T
- Tve
- Et
- Ev

These values are copied into temporary arrays (for safety) and passed to Mutation++ inside the method:

    correct_he()

(lines 199 to 355)

The main call is:

    mutationMixPtr_->step(
        dtSolver,
        rho[celli],
        Y_mut,
        Et_local,
        Ev_local,
        Ttr,
        Tv
    );

This function updates the two temperatures according to the model described in the paper.

mutationMixPtr_ is a wrapper class providing access to the Mutation++ library.

--------------------------------------------------------------------
WHAT STILL NEEDS TO BE MODIFIED

1) Chemistry is not working
   - Species do not react
   - Species mass fractions remain constant
   - This is especially evident since the test case contains only one cell

2) Post-processing
   - A graph of the two temperatures (T and Tve) must be generated for this test case

3) Make it consistent for multiple cells
   - Ensure all per-cell arrays (Y, T, Tve, Et, Ev, rho, etc.) are updated inside loops over celli
   - Confirm Mutation++ calls and state transfer are performed per cell (or vectorized safely)
   - Verify species ordering consistency is preserved identically for every cell
   - Validate results on a small multi-cell mesh before scaling up

